# ğŸ’» Day 16 â€“ OOP Coffee Machine (Python)

## ğŸ“– Project Overview
This project is an Object-Oriented implementation of a **Coffee Machine simulator.** 

The application simulates a real-world coffee machine that:

- Tracks available resources (water, milk, coffee)
- Processes coin input
- Handles transactions
- Deducts ingredients after successful purchases
- Generates reports
- Shuts down via command input

The project transitions from procedural programming to a clean OOP-based architecture using multiple classes to separate responsibilities.

---

## ğŸ¯ Learning Objectives
- Understand and implement Object-Oriented Programming (OOP)
- Work with classes and object composition
- Separate concerns across multiple modules
- Simulate real-world system behavior
- Manage state through class instances
- Improve program structure and maintainability

---

## ğŸ•¹ï¸ Key Features
- Menu-driven coffee selection
- Resource tracking (water, milk, coffee)
- Coin processing and transaction validation
- Automatic change calculation
- Ingredient deduction after purchase
- Machine report generation
- Shutdown command (`off`)
- Modular class-based design

---

## ğŸ§  Key Concepts Covered
- Classes and objects
- Encapsulation
- Instance attributes and methods
- Object composition
- State management
- Conditional logic
- Modular design
- Real-world system modeling

---

## ğŸ› ï¸ Technologies Used
- Python 3.x
- Object-Oriented Programming principles
- Modular file structure

Typical Project Files:

- `main.py`
- `coffee_maker.py`
- `menu.py`
- `money_machine.py`

---

## ğŸ“‚ Project Structure

    day_16_oop_coffee_machine/
    â”‚
    â”œâ”€â”€ main.py
    â”œâ”€â”€ coffee_maker.py
    â”œâ”€â”€ menu.py
    â””â”€â”€ money_machine.py

---

## ğŸ§© Architecture Overview
This project follows a clean object-oriented architecture:

- **Menu Class** â†’ Handles available drinks and pricing
- **CoffeeMaker Class** â†’ Manages ingredient resources
- **MoneyMachine Class** â†’ Processes payments and transactions
- **Main Application** â†’ Coordinates interaction between components

This separation improves:

- Maintainability
- Readability
- Reusability
- Scalability

Each class has a single responsibility, following solid design principles.

---

## ğŸ“Œ Purpose
The purpose of this project is to transition from procedural programming to a structured OOP-based system.

It demonstrates how to model real-world machines using objects that interact with each other â€” an essential concept in backend engineering and scalable application design.

---

## ğŸš€ Potential Improvements
- Add persistent resource storage (file or database)
- Implement a graphical user interface (Tkinter)
- Add unit tests for each class
- Introduce logging system
- Add more drink customization options
- Convert to a REST API (Flask or FastAPI)
- Add error handling for invalid inputs

---

## âœ… Outcome
By completing this project, the learner gains:

- Practical experience with multi-class OOP systems
- Understanding of object composition
- Ability to model real-world systems in code
- Stronger architectural thinking
- A portfolio-ready intermediate Python project

---

â˜• Clean design. Modular logic. Real-world simulation.